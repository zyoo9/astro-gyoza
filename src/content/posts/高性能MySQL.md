---
title: 高性能 MySQL
date: 2024-07-07
summary: 这是一篇 关于《高性能MySQL》的读书笔记。
category: 例子
tags: [MySQl]
---

# 第一章 MySQL 架构

## MySQL的逻辑架构

![image.png](https://cdn.nlark.com/yuque/0/2024/png/26880933/1717400936606-c2b034e4-1ed7-4cce-9f1c-52794890e703.png#averageHue=%23cacaca&clientId=ud9a40254-4dee-4&from=paste&height=398&id=u986803c0&originHeight=286&originWidth=224&originalType=binary&ratio=2&rotation=0&showTitle=false&size=68333&status=done&style=none&taskId=ua38333f2-a44c-4db5-95be-6885c0980af&title=&width=312)
上图表示MySQL的架构逻辑实现图
最上层的客户端是服务器工具，功能主要包括连接处理，身份验证，确保安全性等。
第二层为MySQL的核心功能层，包含查询解析，分析，优化，以及所有的内置函数（日期，数学，加密函数等），所有的跨存储引擎的功能也都在这一层实现：存储过程，触发器，视图。
第三层是存储引擎层，负责MySQL中数据的存储和提取，每种存储引擎都有优劣，服务器通过存储引擎的API进行通信。存储引擎还包含几十个底层函数，进行事务等操作。但是存储引擎不会解析SQL，不同存储引擎之间也不会相互通信，只是简单的响应服务器的请求。

### 连接管理与安全性

默认情况下，每个客户端连接都会在服务器进程中拥有一个线程，该连接的查询只会在这个单独的线程中进行，该县城驻留在一个内核或者CPU上。服务器维护了一个缓冲区（线程池），存放已就绪的线程。
当客户端连接MySQL服务器的时候，服务器需要进行身份校验，验证该客户端是否具有发出每个查询的权限。

### 优化与执行

MySQL解析查询以创建内部数据结构（解析树），然后对其进行各种优化，包括重写查询，决定表的读取顺序，选择合适的索引。用户可以通过特殊的关键字向优化器传递提示，从而影响优化器的决策过程。
旧版本中MySQL使用内部查询缓存（query cache）查看是否直接提供结果，但是由于并发行的增加，在8.0版本之后完全废除，目前更好的设计模式是在memcached/Redis中缓存数据。

## 并发控制

无论何时，只要有多个查询需要同时修改数据，就会产生并发控制问题，本节只讨论MySQL在两个级别的并发控制：服务器级别与存储引擎级别

### 读写锁

处理并发读/写访问的系统通常实现一个由两种锁类型组成的锁系统，通常为共享锁（shared lock）和排他锁（exclusive lock），也叫读锁（read lock）和写锁（write lock）。
锁的概念可以描述为：资源上读锁是共享的，相互不阻塞的。多个客户端可以同时读取同一个资源而互不干扰。写锁是排他的，一个写锁即会阻塞读锁也会阻塞其他的 写锁，只有这样才能确保特定的时间只有一个客户端可以执行写入。

### 锁的粒度

一种提高共享资源并发性的方式就是让锁定的对象更有选择性，尽量只锁定包含修改的部分数据，最理想的方式是只锁定当前修改的数据。
问题是加锁，释放锁都要消耗资源，增加系统开销，如果大量时间来管理锁，系统的性能可能收到影响。
锁定策略是锁开销和数据安全性之前的平衡，这种平衡会影响性能，一般都是在表中加入行锁（row level lock）。锁是数据库实现一致性保证的方法。

### 表锁

表锁（table lock）是MySQL中最基本也是开销最小的锁策略。
当客户端想要对表进行写操作的时候，会先获得一个写锁，这会阻塞其他客户端对该表的所有读写操作。表锁也有一些变体，可以提高特定情况的性能。例如，READ LOCAL表锁支持某些类型的并发写操作。写锁队列和读锁队列分开，但是写锁队列优先级绝对高于读锁队列。

### 行级锁

使用行级锁可以最大程度支持并发处理，但是带来了最大的锁开销

## 事务

事务就是一组SQL语句，作为一个工作单元以原子方式进行处理，要么全部成果，要么全部失败。
可以用START TRANSACTION 开启事务，然后要么使用COMMIT提交事务，将修改的数据持久保留，要么使用ROLLBACK 回滚所有修改。
除非系统通过了严格的ACID测试，否则空谈事务的概念是不够的。ACID代表原子性（atomicity），一致性（consistency），隔离性（isolation）和持久性（durability）。确保数据安全的事务处理系统。

- 原子性：整个事务中的所有操作要么全部成果，要么全部失败回滚。
- 一致性：数据库总是从一个一致性状态切换到下一个一致性状态。（事务要么成果，要么失败）
- 隔离性：通常来说，一个事务所做的修改在最终提交之前对其他事务时不可见的。
- 持久性：一旦提交，事务所做的修改就会被永久保存到数据库中。

### 隔离级别

- READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其他事务也都是可见的，事务可以读取未提交的数据，这就是脏读（Dirty Read）。这个级别会导致很多问题，并且性能上不会好很多，很少使用。
- READ COMMITTED（提交读）：大多数数据库默认都是（MySQL不是）。一个事务从开始直到提交前，所做的任务修改其他的事务都不可见。这个级别有时候也叫做不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果。
- REPEATABLE READ（可重复读）：该级别保证了在同一事务中多次读取同样记录的结果是一致的，但是理论上，可重复读还是无法解决幻读的问题。幻读指当某个事物读取某个范围内的记录时，另一个事物又在这个范围内插入了新的记录，当之前的事务再次读起该范围内的数据，就会产生幻行，InnoDB通过MVCC解决了幻读问题。
- SERIALIAZABLE（可穿行化）：该是最高的隔离级别，强制事务串行执行，简单来说就是每行数据都会加锁，可能导致大量的超时和锁争用的问题。当非常确保数据一致而去可以接受没有并发的情况下，才考虑。

### 死锁

死锁就是两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
InnoDB目前处理死锁的方式就是将持有最少行级排他锁的事务会滚。

### 事务日志

事务日志可以帮助提高事务的效率。存储引擎在修改表的数据时，只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘的事务日志中，而不用每次都将修改的数据本身吃就到硬盘。事务日志采用追加的方式，写操作是硬盘上一小块区域的顺序I/O。日志持久化之后内存中被修改的数据可以慢慢刷回到磁盘。
如果事务日志已经持久化，但数据本身还没写回磁盘，此时系统崩溃，存储引擎重启的时候能够自动回复这部分修改的数据。

### 理解AUTOCOMMIT

默认情况下，每个SQL语句都会隐式包装成一个事务并在执行成功后立即提交，这是自动提交。禁用之后当前连接总是处于某个事务中，知道发生COMMIT/ROLLBACK，然后MySQL回立即启动一个新的事务

## 多版本并发控制

MySQL的大多数事务型存储引擎实现的都不是简单的行级锁，基于提升并发性能的考虑，一般都实现了多版本并发控制（MVCC）。
可以认为MVCC是行级锁的一个变种，但是他在很多情况下避免了加锁操作，大都实现了非阻塞的读操作，写操作也只锁定必要的行。
MVCC的实现，是通过保存数据在某个时间点的快照来实现的，也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的，根据事物开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。
InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的，这两个列，一个保存了行的创建时间，一个保存行的过期时间（删除时间）。当然存储的并不是实际的时间值，而是系统版本号，每开始一个新的事务，系统版本号都会递增。事务开始适合的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。
MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作，其他两个都不兼容。

# 第六章 schema 设计与管理

## 选择优化的数据类型

MySQL支持的数据类型很多，但是虚啊找你正确的数据类型对于获得高性能至关重要。
更小的通常更好
一般来说，尽量使用能够正确存储和表示数据的最小数据类型。更小的数据类型更快，占用磁盘，内存和CPU缓存的空间更小。
简单为好
简单数据类型的操作通常需要更少的CPU周期，整形数据比字符型数据的比较操作代价更低，因为字符集和排序规则使字符型数据的比较更复杂。
尽量避免存储NULL
通常情况下最好指定列为NOT NULL，除非明确需要存储NULL值。如果查询中包含可为NULL的列，对MySQL来说很难优化，因为可能为NULL的列使得索引，索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL中也要特殊处理。

### 整数类型

有两种类型的数字：整数和实数（带有小数部分的数字）。如果存储整数可以使用：TINYINT（8），SMALLINT（16），MEDIUMINT（24），INT（32）和BIGINT（64）
整数类型的有可选的UNSIZNED属性，表示不允许为负值。
有符号和无符号使用的是相同的空间，具有一样的性能。
整数类型的计算通常使用64位的BIGINT整数。

### 实数类型

实数是带有小数部分的数字，然而，不仅适用于带小数的数字，也可以使用DECIMAL存储比BIGINT还大的整数。
浮点类型通常比DECIMAL使用更少的空间来存储相同范围的值。FLOAT列使用4字节的存储空间。DOUBLE占用8字节，比FLOAT具有更高的精度和更大的值范围，MySQL会使用DOUBLE进行浮点类型的内部计算。
由于额外的空间需求和计算成本，尽量只在小数进行精确计算时才使用DECLMAL--例如，存储财务数据。但是一些大容量的场景，考虑BIGINT代替DECIMAL，将货币根据小数位数乘以相应的倍数即可，可以避免浮点储存计算不精确和DECLMAL精确计算代价高的问题。

### 字符串类型

VARCHAR
用于存储可变长度的字符串，比固定长度的类型更节省空间。VARCHAR需要额外使用1/2字节记录字符串长度，取决于列最大长度，大于255就是2字节。
VARCHAR节省了存储空间，所以对性能也有帮助，但是，由于是可变长度，在更新时可能会增长。InnoDB辉通过分割页面来容纳行。
CHAR
CHAR是固定长度，适合存储非常短的字符串。
BLOB和TEXT类型
这两个类型都是为存储很大的数据而设计的，分别采用二进制和字符方式存储。MySQL不能将BLOB和TEXT类型的完整字符串放入索引，也不能使用索引进行排序。
使用枚举代替字符串
有时候可以使用ENUM代替常规的字符串类型，MySQL中存储枚举的时候非常紧凑，压缩到1/2字节。
ENUM字段是根据内部的整数来排序，而不是字符串本身。
存在慢的问题：将CHAR/VARCHAR列连接到ENUM列可能比连接到另一个CHAR/VARCHAR慢。
日期和时间类型
DATETIME：可以保存大范围的数值，格式是YYYYMMDDHHMMSS格式压缩整数的日期和时间，与时区无关，需要8字节的存储空间。
TIMESTAMP：存储格林威治时间的时间戳，范围比DATETIME小很多，并且时间戳依赖时区。

## schema 设计中的陷阱

### 太多的列

MySQL的存储引擎API通过在服务器和存储引擎之间以行缓冲区格式复制行来工作，服务器将缓冲区解码为列。将行缓冲区转换为具有解码列的行数据结构的操作代价非常高。

### 太多的联接

MySQL中限制每个联接有61个表，但是EAV模式设计的数据库需要很多自联接。规划和优化查询的成本对MySQL来说也是很大的问题。如果需要以高并发性快速执行查询，那么每个查询最好少于十几个表。

### 全能的枚举

### NULL不是虚拟值

如果需要表中存储事实上的“空值”，尽可能不使用NULL，可以使用1，特殊值或空字符串来代替。但是这不是绝对的，如果一定需要NULL，也可设置。
细节的一点，MySQL会对NULL进行索引，Oracle不会

# 第七章 创建高性能的索引

索引，在MySQL中也叫做键（key），是存储引擎用于快速找到记录的一种数据结构。

## 索引基础

```sql
SELECT first_name FROM actor WHERE id = 5
```

MySQL现在索引上按照值进行查找，然后返回所有包含值的记录。
索引可以包含一列或多列，如果包含多列，那么必须匹配**最左前缀列**。创建一个两列的索引和两个一列的索引大不相同。

### 索引的类型

索引在存储引擎层实现的，所以索引并没有统一的标准，不同的存储引擎的索引的工作方式不一样，也不是所有的存储引擎都包含所有的索引。

#### B-tree索引

讨论索引的时候，如果没有特殊说明，多半是 B-tree 索引，使用 B-tree 来存储数据。大多数 MySQL 都支持这种索引。InnoDB 是使用 B+tree树。
B-tree通常意味着所有的值按照顺序存储，并且每一个叶子页到根的距离相同。
B-tree索引可以加快访问数据的速度，因为有了索引，查询的时候从根节点开始，根的槽中存放了指向子节点的指针，存储引擎通过这些指针向下查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层节点。这些指针实际上定义了叶子节点的上限和下限。
叶子节点比较特殊，它的指针指向的是被索引的数据，而不是其他节点页。
B-tree是按照索引列中的数据大小顺序存储，很适合按照范围查询。
**自适应哈希索引**：InnoDB上有一个特性，当InnoDB发现某些索引值被非常频繁的访问，他会在原油的B+tree的基础上，在内存中再构建一个哈希索引，可以实现非常快速的哈希查找。
可以使用B-tree索引的查找类型。

- 全值匹配：查询的值和索引的所有列匹配。
- 匹配最左前缀：可以只使用索引的第一列（多列索引，多个索引列）
- 匹配列前缀：只匹配某一列的值的开头部分（前缀索引）
- 匹配范围值：在只使用第一列索引的情况下，范围查找。
- 精确某一列而范围匹配另外一列：只允许第一列是全值匹配，后面使用索引列范围查询。
- 只访问索引的查询：可以只访问索引列，这种情况下无需回表查询数据（覆盖索引优化）。

B-tree的限制：

- 如果不是按照索引的最左列开始查找，则无法使用索引。（匹配最左原则）
- 不能跳过索引中的列。
- 如果查询中有一列是范围查询，则右边所有列都无法使用索引优化查找。

#### 全文索引

FULLTEXT 是一种特殊的索引，它是查找文中的关键词，而不是直接比较索引中的值

#### 使用索引的优点

索引可以让服务器快速定位到表的指定位置，并且因为索引的数据是按顺序排列的，索引可以用 ORDER BY 和 GROUP BY 操作排序。

- 索引大大减少了服务器需要扫描的数据量。
- 索引可以帮助服务器避免排序和临时表。
- 索引可以将随机I/O变为顺序I/O。

## 高性能的索引策略

### 前缀索引和索引的选择

有时候为了提高索引的性能，同时节省索引空间，可以只对字段的一部分字符进行索引，这样做的缺点是：降低索引的选择性。
索引的选择性：不重复的索引值和数据表的记录总数的比值。索引的选择性越高则查询的效率越高。
唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。
一般情况下，列前缀的选择性也是足够高的，足以满足查询性能，对于 BLOB，TEXT或者很长的VARCHAR类别的列，必须使用前缀索引，因为MySQL不支持这些列的完整内容进行索引。
这里的关键点在于，既要选择足够长的前缀以保证较高的选择性，同时也不能太长（节省空间）。
前缀索引是一种能使索引更小，更快的有效方法，但是他也有缺点：因为无法排序，所以不能做 ORDER BY 和 GROUP BY 操作，也无法使用索引扫描。
一个很常见的场景就是很长的十六进制唯一ID使用前缀索引。

### 选择合适的索引列顺序

在一个多列B-tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列。
索引可以按照升序或者降序进行扫描，满足精确符合列顺序的ORDER BY GROUP BY DISTINCT 等子句的查询需求。
当不需要考虑排序和分组的时候，选择最高的列放在前面通常是很好的，这时索引的作用只是优化查询语句中的WHERE条件，在这种情况下，按照这个原则设计的索引确实能够最快的过滤出需要的行，并且可以根据运行频率最高的查询来调整索引列的顺序，这种情况下索引的选择性更高。

### 聚簇索引

聚簇索引是数据存储的方式，在B-tree上保存了索引和数据行。
当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中，表示数据行和相邻的键值紧凑地存储在一起，所以一张表只能有一个聚簇索引。
InnoDB根据主键聚簇数据，如果你没有定义主键，InnoDB会选择一个唯一的非空索引歹徒，如果没有，InnoDB会隐式定义一个主键作为聚簇索引。这样的缺点就是，需要使用这种隐藏主键的表都依赖一个单点的“自增值”，这可能导致非常高的锁竞争，从而出现性能问题。
聚簇索引优点：

- 可以把相互关联的数据保存在一起，防止全局I/O
- 数据访问的更快，聚簇索引将索引和数据保存在同一个B-tree中，因此聚簇索引中获取数据比非聚簇索引更快。
- 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

聚簇索引缺点：

- 聚簇索引最大限度提高了I/O密集型应用的性能，但是如果数据全部存放到内存中，那么访问数据就没真么重要了，也就没什么优势了。
- 插入速度严重依赖于插入顺序，按照主键的顺序插入行是将数据加载到InnoDB表中最快的方式，但是如果不是，那么需要在加载完之后最好使用 OPTIMIZE TABLE 命令重新组织表。
- 更新聚簇索引的代价很高，因为它会强制InnoDB将每个被更新的行移动到新的位置。
- 在插入新行，或者更新主键需要移动行的时候，可能面临页分裂（page spilt）的问题。当行的主键值必须移动到一个已经满了的页中，存储引擎会将该页分裂成两个页面来容纳该行。页分裂会导致表占用更多的磁盘空间。
- 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者页分裂导致数据存储不连续的时候。

### InnoDB的数据分布

InnoDB默认为主键聚簇索引。
聚簇索引的每一个叶子节点都包含了主键值，事务ID，用于事务和MVCC的回滚指针。

#### 在InnoDB表中按主键顺序插入行

如果正在使用InnoDB表，并且没有什么数据需要聚集，那么可以定义一个代理键作为主键，这种主键与业务无关，并且使用AUTO_INCREMENT自增列，确保数据行是按照顺序写入。
最好避免随机的聚簇索引，特别是I/O密集型应用。
如果使用UUID作为聚簇索引列，会导致插入的很糟糕，没有任何聚簇特性。

### 覆盖索引

如果一个索引包含所有需要查询的字段的值，我们称之为覆盖索引，需要注意的是只有B-tree索引可以用于覆盖索引。
覆盖索引非常有用，如果查询只需要扫描索引而无需回表，就会减少一次I/O。

- 索引条目通常远小于数据行大小，所以如果只需要读取索引，那么就会极大减少数据访问量。这对缓存型的应用负载非常重要，在这种情况下，相应事件大部分花费在数据拷贝上。
- 由于InnoDB的聚簇索引特点，覆盖索引对InnoDB表特别有用。

### 使用索引扫描来排序

MySQL有两种方式可以生成有序的结果：通过排序操作，或者按索引顺序扫描。
如果在EXPLAIN 输出结果中，type列的值为“index”，则说明MySQL使用了索引扫描做排序。
如果索引不能是覆盖索引，就需要每一列都回表查询，变成随机I/O。

# 第八章 查询性能优化

## 满查询基础：优化数据访问

大部分性能底下的查询都可以通过减少访问数据量的方式进行优化

1. 确认是否在检索大量且不必要的数据
2. 确认MySQL服务器层是否在分析大量不需要的数据行

### 是否向数据库请求了不需要的数据

- 查询了不需要的记录，常常误以为MySQL只会返回需要的数据，实际上MySQL先返回所有的数据然后再进行计算，最简单的方式就是添加 LIMIT
- 多表链接的时候返回全部列
- 总是取出全部列，取出全部列，会让优化器无法完成索引覆盖扫描这类优化，减少 SELECT \*
- 重复查询相同的数据，初次查询之后缓存起来，不用再次查询

## 重构查询的方式

### 一个复杂的查询还是多个简单查询

在设计查询的时候，将一个复杂的查询拆分成多个简单查询，然后数据操作放在内存中。
在MySQL内部，每秒能扫描内存中上百万数据，相比之下，MySQL相应数据给客户端就慢很多，在其他条件不变的情况下，使用尽可能少的查询当然更好，但是将一个大的查询分解成多个小的查询很有必要。

### 切分查询

定期清除大量数据的时候，如果一个大的语句一次性完成的话，可能一次锁住很多数据，占满事务日志，耗尽系统资源。
将一个大的 DELETE 语句切分成多个较小的查询，尽可能小的影响MySQL的性能，同时还可以降低MySQL的复制延迟。

### 分解联接查询

很多高性能的应用都会对联接查询进行分解，进行单表查询，然后在应用程序中联接。
优势：

- 拆分查询之后，执行单个SQL可以进少锁竞争
- 在应用层进行联接，可以更容易对数据库进行拆分
- 减少冗余记录的查询
